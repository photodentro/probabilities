<!doctype html> 
<!-- Copyright (C) 2018 Alkis Georgopoulos <alkisg@gmail.com>. License: GPLv3. -->
<html lang="el"> 
<head> 
  <meta charset="UTF-8" />
  <!-- Using this metatag users can't scale the page using pinchIn/out gestures on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>Τροχός της τύχης - Πιθανότητες</title> 
  <script src="https://code.createjs.com/1.0.0/easeljs.min.js"></script>
  <style type="text/css">
    /* Remove margins and HTML scrollbars */
    body, html  {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
    }
    #mainCanvas {
    padding: 0;
    margin: auto;
    display: block;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    }
  </style>
</head>
<body onload = "init();">
  <canvas id="mainCanvas" width="320" height="180">
    Your browser doesn't support HTML5!
  </canvas>
<script>
  var stage;
  var resourceNames = ["background.svg","bar_help.svg","bar_home.svg", "bar_edit.svg"];
  var resourcesLoaded = 0;
  var resources = [];
  var ratio = 16/9;
  var winratio;
  var boxl;
  var boxr;
  var boxHeight;
  var boxWidth;
  var spinningWheel;
  var wheelSpins = false;
  //rotation speed starts from init and 
  //decreases by step steps
  var rotConfig = {'init':10,'stretch':1};
  var rotSpeed;
  var triangleMark;
  var colors;
  var probabilities;
  var menubar = [];
  var bg;
  var chartData = [];
  var rectangles = [];

  function init(){
    console.clear();
    stage = new createjs.Stage("mainCanvas");
    stage.enableMouseOver();
    
    // Resource preloading
    for (var i = 0; i < resourceNames.length; i++) {

      resources[i] = new Image();
      resources[i].src = "resource/" + resourceNames[i];
      resources[i].onload = queueFileLoad;

    }
    // The last queueFileLoad calls queueComplete. Execution continues there.

  }

function imgByName(name) {
  return resources[resourceNames.indexOf(name)];
}

function queueFileLoad(event) {
  resourcesLoaded++;
  stage.update();
  if (resourcesLoaded == resourceNames.length)
    queueComplete(event);
}

function queueComplete(event) {
  console.log("Finished loading resources");
  bg = new createjs.Bitmap(imgByName("background.svg"));
  stage.addChild(bg);
  
  var onMenuClick = [onMenuHelp, onMenuHome];
  for (i = 0; i < 3; i++) {

    menubar[i] = new createjs.Bitmap(resources[resourceNames.indexOf('bar_help.svg')+i]);
    menubar[i].addEventListener("click", onMenuClick[i]);
    menubar[i].addEventListener("mouseover", function(event) {
        // Bring the target on top in its container, mostly for the rotation animation
        event.target.parent.setChildIndex(event.target, event.target.parent.numChildren - 1);
        event.target.scaleX = 1.2*event.target.savedscaleX;
        event.target.scaleY = 1.2*event.target.savedscaleY;
        stage.update();});
    menubar[i].addEventListener("mouseout", function(event) {
        event.target.scaleX = event.target.savedscaleX;
        event.target.scaleY = event.target.savedscaleY;
        stage.update();});
    stage.addChild(menubar[i]);
    
  }
  lvlText = new createjs.Text("1", "20px Arial", "white");
  lvlText.textAlign = "center";
  lvlText.textBaseline = "middle";
  stage.addChild(lvlText);

  //begin two boxes
  boxl = new createjs.Shape();
  stage.addChild(boxl);
  contl = new createjs.Container();
  stage.addChild(contl);

  boxr = new createjs.Shape();
  stage.addChild(boxr);
  contr = new createjs.Container();
  stage.addChild(contr);

  spinningWheel = new createjs.Shape();
  spinningWheel.addEventListener('click',function (){
    var whatDoIWant = Math.floor(Math.random()*9);
    var newAngle = 270+360+Math.floor(whatDoIWant)*45;
    rotConfig = computeSpeed(newAngle);
    rotSpeed = rotConfig['init'];
    wheelSpins = true;
  });
  contl.addChild(spinningWheel);
  triangleMark = new createjs.Shape();
  contl.addChild(triangleMark);
  contl.setChildIndex(contl.numChildren - 1);

  stage.update();
  initLevel(0);
  resize();
  window.addEventListener('resize', resize, false);
  createjs.Ticker.on("tick", tick);
}

function computeSpeed(angle){
  var initSpeed = 30;
  totalSteps = initSpeed*(initSpeed+1)/2;
  var stretch = 1.0*angle/totalSteps;
  return({'init':initSpeed,'stretch':stretch})
}

function initLevel(newLevel) {
  /*Levels
   *0 -> colors:        ['orange','lightgreen']
   *  -> probabilities: [75,25]*/
  level = newLevel;
  levelColors = [['orange','lightgreen'],
                 ['orange','lightgreen','aquamarine'],
                 ['red','green','blue','yellow','pink','lightgreen','lightblue','magenta'],
                ];
  levelProbabilities = [[75,25],
                        [33.33,33.33,33.34],
                        [12.5,12.5,12.5,12.5,12.5,12.5,12.5,12.5,],
                ];
  colors = levelColors[newLevel];
  probabilities = levelProbabilities[newLevel];
  chartData = [];
  for (var i = 0; i<colors.length; i++){
    chartData.push(0);
  }
  wheelSpins = false;
  resize();
}

function resize() {
  // Resize the canvas element
  winratio = window.innerWidth/window.innerHeight;
  if (winratio >= ratio) {
    stage.canvas.height = window.innerHeight;
    stage.canvas.width = stage.canvas.height * ratio;
  } else {
    stage.canvas.width = window.innerWidth;
    stage.canvas.height = stage.canvas.width / ratio;
  }
  var bbs = stage.canvas.height / 10;  // bar button size

  var bbm = bbs / 5;  // bar button margin
  // TODO: local/global variables, eslint...
  for (i = 0; i < 3; i++) {
    menubar[i].scaleX = bbs / menubar[i].image.width;
    menubar[i].scaleY = bbs / menubar[i].image.height;
    menubar[i].regX = menubar[i].image.width / 2;
    menubar[i].regY = menubar[i].image.height / 2;
    menubar[i].x = (i + 1)*bbm + bbs/2 + i*bbs;
    menubar[i].y = stage.canvas.height - bbm - bbs/2;
    menubar[i].visible = true;
    // These copies are used to preserve the original scale on mouseover
    menubar[i].savedscaleX = menubar[i].scaleX;
    menubar[i].savedscaleY = menubar[i].scaleY;
  }


  // Fill all the canvas with the background
  bg.scaleX = stage.canvas.width / bg.image.width;
  bg.scaleY = stage.canvas.height / bg.image.height;



  //begin boxes
  margin = stage.canvas.width/100;
  var x_available = stage.canvas.width - (5*margin+margin+5*margin);
  boxWidth = x_available/2;
  boxHeight = stage.canvas.height - bbs - bbm - margin;
  boxl.x = 5*margin;
  boxl.y = margin;
  boxl.alpha = 0.5;
  boxl.graphics.clear();
  boxl.graphics.beginStroke("#000");
  boxl.graphics.setStrokeStyle(1);
  boxl.graphics.beginFill("DarkTurquoise").drawRoundRect(0, 0, boxWidth, 
    boxHeight, margin);
  contl.x = boxl.x + margin;
  contl.y = boxl.y + margin;
 
  boxr.x = 5*margin+x_available/2+margin;
  boxr.y = margin;
  boxr.alpha = 0.5;
  boxr.graphics.clear();
  boxr.graphics.beginStroke("#000");
  boxr.graphics.setStrokeStyle(1);
  boxr.graphics.beginFill("OrangeRed").drawRoundRect(0, 0 , boxWidth, boxHeight, margin);
  contl.x = boxl.x + margin;
  contl.y = boxl.y + margin;
 
  spinningWheel.x = boxWidth/2 - margin;
  spinningWheel.y = boxHeight/2 - 2*margin;
  //colors and probabilities are set in initLevel
  drawSpinningWheel(boxWidth/2-2*margin,colors,probabilities);
  drawChart();
  triangleMark.graphics.clear();
  triangleMark.x = spinningWheel.x;
  triangleMark.y = contl.y - margin;
  triangleMark.graphics.beginStroke('black').beginFill('black').moveTo(-margin,0).lineTo(margin,0).lineTo(0,margin).lineTo(-margin,0).closePath();
  stage.update();
}


function drawSpinningWheel(r,colors,probabilities){
  var startAngle = 0;
  var endAngle = 0;
  spinningWheel.graphics.clear();
  spinningWheel.rotation = 270;//turns wheel towards triangle
  /*spinningWheel.graphics.beginFill('black').arc(0,0,r,0,2*Math.PI*2/100);
  spinningWheel.graphics.lt(0,0);*/
  
  for (var i = 0; i<colors.length; i++){
    endAngle = startAngle + 2*Math.PI*probabilities[i]/100;
    spinningWheel.graphics.beginFill(colors[i]).arc(0,0,r,startAngle,endAngle);
    spinningWheel.graphics.lt(0,0);
    startAngle = endAngle; //for next arc
  }
}




function onMenuHelp(event) {
  alert("Επιλέξτε εικόνες από το κάτω κουτί και βάλτε τις στο δεξί κουτί έτσι ώστε να ταιριάζουν με το αριστερό κουτί.");
}

function onMenuHome(event) {
  window.history.back();
}


function colorIndex(){
  var nextDegree = 0;
  var adjustedRotation =  270 - spinningWheel.rotation%360;
  if (adjustedRotation < 0){
    adjustedRotation+=360;
  }
  
  for (var i=0; i<colors.length; i++){
    nextDegree += probabilities[i]*360/100;
    if (adjustedRotation<nextDegree){
      return(i);
    }
  }
}
function drawChart(){
  for (var i=0; i<rectangles.length; i++){
      for (var j=0; j<rectangles[i].length; j++){
        rectangles[i][j].graphics.clear();
    }
  }
  stage.update();
  rectangles = [];
  for (var i=0; i<colors.length; i++){
    rectangles.push([]);
    for (var j=0; j<chartData[i]; j++){
      rectangles[i][j] = new createjs.Shape();
      contr.addChild(rectangles[i][j]);
      var rectWidth = (boxWidth-1*(colors.length+1)-2*margin)/colors.length;
      var rectHeight = boxHeight/15 - 15;
      var rectX = boxr.x+margin+i*(rectWidth+1);
      var rectY = boxr.y+boxHeight - (j+1)*(rectHeight+1);
      rectangles[i][j].graphics.beginFill(colors[i]).drawRoundRect(rectX,rectY,rectWidth,rectHeight,2);
    }
  }
  stage.update();
}

function tick(){
  if (wheelSpins){
    rotSpeed -= 1;
    spinningWheel.rotation = spinningWheel.rotation+rotSpeed*rotConfig['stretch'];
    if (rotSpeed < 0.1){
      wheelSpins = false;
      var ci = colorIndex();
      chartData[ci] += 1;
      drawChart();
    }
  }
  stage.update();
}
</script>
</body>
</html>